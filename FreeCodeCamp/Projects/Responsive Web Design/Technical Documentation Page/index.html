<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" type="text/css" href="style.css">
    <title>Technical Documentation Page</title>
</head>
<body>
    <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>

    <nav id="navbar">
        <header>JS Documentation</header>
        <ul>
            <a class="nav-link" href="#Introduction" rel="internal"><li>Introduction</li></a>
            <a class="nav-link" href="#Grammar_and_Types" rel="internal"><li>Grammar and Types</li></a>
            <a class="nav-link" href="#Hello_world" rel="internal"><li>Hello world</li></a>
            <a class="nav-link" href="#Functions" rel="internal"><li>Functions</li></a>
            <a class="nav-link" href="#Array_object" rel="internal"><li>Array object</li></a>
            <a class="nav-link" href="#Constructor" rel="internal"><li>Constructor</li></a>
            <a class="nav-link" href="#If_..._Else_Statement" rel="internal"><li>If ... Else Statement</li></a>
            <a class="nav-link" href="#Switch_Statement" rel="internal"><li>Switch Statement</li></a>
            <a class="nav-link" href="#Declarations" rel="internal"><li>Declarations</li></a>
            <a class="nav-link" href="#Comments" rel="internal"><li>Comments</li></a>
            <a class="nav-link" href="#Conditional_operator" rel="internal"><li>Conditional operator</li></a>
            <a class="nav-link" href="#String_objects" rel="internal"><li>String objects</li></a>
            <a class="nav-link" href="#Arrow_functions" rel="internal"><li>Arrow functions</li></a>
            <a class="nav-link" href="#Defining_getters_and_setters" rel="internal"><li>Defining getters and setters</li></a>
            <a class="nav-link" href="#Reference" rel="internal"><li>Reference</li></a>
        </ul>
    </nav>
    <main id="main-doc">
        <section class="main-section" id="Introduction">
            <header>Introduction</header>
            <article>
                    <p>JavaScript is a cross-platform, object-oriented scripting language used to make webpages interactive (e.g. having complex animations, clickable buttons, popup menus, etc.).  There are also more advanced server side versions of JavaScript such as Node.Js which allow you to add more functionality to a website than simply downloading files (such as realtime collaboration between multiple computers). Inside a host environment (for example, a web browser), JavaScript can be connected to the objects of its environment to provide programmatic control over them.</p>
                    <p>JavaScript contains a standard library of objects, such as Array, Date, and Math, and a core set of language elements such as operators, control structures, and statements. Core JavaScript can be extended for a variety of purposes by supplementing it with additional objects; for example:</p>
                    <li>Client-side JavaScript extends the core language by supplying objects to control a browser and its Document Object Model (DOM). For example, client-side extensions allow an application to place elements on an HTML form and respond to user events such as mouse clicks, form input, and page navigation.</li>
                    <li>Server-side JavaScript extends the core language by supplying objects relevant to running JavaScript on a server. For example, server-side extensions allow an application to communicate with a database, provide continuity of information from one invocation to another of the application, or perform file manipulations on a server.</li>
                    <p>This means that in the browser, JavaScript can change the way the webpage (DOM) looks. And, likewise, Node.js JavaScript on the server can respond to custom requests from code written in the browser.</p>
            </article>
        </section>
        <section class="main-section" id="Grammar_and_Types">
                <header>Grammar and Types</header>
                <article>
                        <p>JavaScript borrows most of its syntax from Java, but is also influenced by Awk, Perl and Python.</p>
                        <p>JavaScript is <b>case-sensitive</b> and uses the <b>Unicode</b> character set. For example, the word Früh (which means "early" in German) could be used as a variable name.</p>
                        <code>var Früh = "foobar";</code>
                        <p>But, the variable früh is not the same as Früh because JavaScript is case sensitive.</p>
                        <p>In JavaScript, instructions are called statements and are separated by semicolons (;).</p>
                        <p>A semicolon is not necessary after a statement if it is written on its own line. But if more than one statement on a line is desired, then they must be separated by semicolons. ECMAScript also has rules for automatic insertion of semicolons (ASI) to end statements. (For more information, see the detailed reference about JavaScript's lexical grammar.) It is considered best practice, however, to always write a semicolon after a statement, even when it is not strictly needed. This practice reduces the chances of bugs getting into the code.</p>
                        <p>The source text of JavaScript script gets scanned from left to right and is converted into a sequence of input elements which are tokens, control characters, line terminators, comments, or whitespace. Spaces, tabs, and newline characters are considered whitespace.</p>
                </article>
        </section>
        <section class="main-section" id="Hello_world">
                <header>Hello world</header>
                <article>
                        <p>To get started with writing JavaScript, open the Scratchpad and write your first "Hello world" JavaScript code:</p>
                        <code>(function() {
        "use strict";
        /* Start of your code */
        function greetMe(yourName) {
                alert('Hello ' + yourName);
        }

        greetMe('World');
        /* End of your code */
})();</code>
                        <p>Select the code in the pad and hit Ctrl+R to watch it unfold in your browser! In the following pages, this guide will introduce you to the JavaScript syntax and language features, so that you will be able to write more complex applications. But, for the time being, remember to always include the <span style="background-color: #ddd"><b>(function(){"use strict";</b></span> before your code, and add <span style="background-color: #ddd"><b>})();</b></span> to the end of your code. You will learn what these mean, but for now they can be thought of as doing the following —</p>
                        <li>Massively improve performance</li>
                        <li>Prevent stupid semantics in JavaScript that trip up beginners</li>
                        <li>Prevent code snippets executed in the console from interacting with one-another (e.g. having something created in one console execution being used for a different console execution).</li>
                </article>
        </section>
        <section class="main-section" id="Functions">
                <header>Functions</header>
                <article>
                        <p>A function definition (also called a function declaration, or function statement) consists of the function keyword,  followed by:</p>
                        <li>The name of the function.</li>
                        <li>A list of parameters to the function, enclosed in parentheses and separated by commas.</li>
                        <li>The JavaScript statements that define the function, enclosed in curly brackets, <span style="background-color: #ddd"><b>{ }</b></span>.</li>
                        <p>For example, the following code defines a simple function named <span style="background-color: #ddd"><b>square:</b></span></p>
                        <code>function square(number) {
        return number * number;
}</code>
                        <p>The function <span style="background-color: #ddd"><b>square</b></span> takes one parameter, called <span style="background-color: #ddd"><b>number</b></span>. The function consists of one statement that says to return the parameter of the function (that is, <span style="background-color: #ddd"><b>number</b></span>) multiplied by itself. The statement <span style="color: blue; background-color: #ddd"><b>return</b></span> specifies the value returned by the function.</p>
                        <code>return number * number;</code>
                        <p>Primitive parameters (such as a number) are passed to functions <b>by value</b>; the value is passed to the function, but if the function changes the value of the parameter, <b>this change is not reflected globally or in the calling function</b>.</p>
                        <p>If you pass an object (i.e. a non-primitive value, such as Array or a user-defined object) as a parameter and the function changes the object's properties, that change is visible outside the function, as shown in the following example:</p>
                        <code>function myFunc(theObject) {
        theObject.make = 'Toyota';
}

var mycar = {make: 'Honda', model: 'Accord', year: 1998};
var x, y;

x = mycar.make; // x gets the value "Honda"

myFunc(mycar);
y = mycar.make; // y gets the value "Toyota"
                // (the make property was changed by the function)</code>
                </article>
        </section>
        <section class="main-section" id="Array_object">
                <header>Array object</header>
                <article>
                        <p>An array is an ordered set of values that you refer to with a name and an index. For example, you could have an array called emp that contains employees' names indexed by their numerical employee number. So emp[1] would be employee number one, emp[2] employee number two, and so on.</p>
                        <p>JavaScript does not have an explicit array data type. However, you can use the predefined Array object and its methods to work with arrays in your applications. The Array object has methods for manipulating arrays in various ways, such as joining, reversing, and sorting them. It has a property for determining the array length and other properties for use with regular expressions.</p>
                        <p>The following statements create equivalent arrays:</p>
                        <code>var arr = new Array(element0, element1, ..., elementN);
var arr = Array(element0, element1, ..., elementN);
var arr = [element0, element1, ..., elementN];</code>
                        <p>element0, element1, ..., elementN is a list of values for the array's elements. When these values are specified, the array is initialized with them as the array's elements. The array's length property is set to the number of arguments.</p>
                        <p>The bracket syntax is called an "array literal" or "array initializer." It's shorter than other forms of array creation, and so is generally preferred. See Array literals for details.</p>
                        <p>To create an array with non-zero length, but without any items, either of the following can be used:</p>
                        <code>var arr = new Array(arrayLength);
var arr = Array(arrayLength);

// This has exactly the same effect
var arr = [];
arr.length = arrayLength;</code>
                        <p id="note"><b>Note</b> : in the above code, arrayLength must be a Number. Otherwise, an array with a single element (the provided value) will be created. Calling arr.length will return arrayLength, but the array actually contains empty (undefined) elements. Running a for...in loop on the array will return none of the array's elements.</p>
                </article>
        </section>
        <section class="main-section" id="Constructor">
                <header>Constructor</header>
                <article>
                        <p>There can be only one special method with the name "constructor" in a class. Having more than one occurrence of a constructor method in a class will throw a SyntaxError error.</p>
                        <p>A constructor can use the super keyword to call the constructor of a parent class.</p>
                        <p>If you do not specify a constructor method, a default constructor is used.</p>
                        <code>class Square extends Polygon {
   constructor(length) {
     // Here, it calls the parent class' constructor with lengths
     // provided for the Polygon's width and height
     super(length, length);
     // Note: In derived classes, super() must be called before you
     // can use 'this'. Leaving this out will cause a reference error.
     this.name = 'Square';
   }

   get area() {
     return this.height * this.width;
   }

   set area(value) {
     this.area = value;
   } 
}</code>
                <p style="color: white; background-color: black; padding: 2px 0 2px 5px"><b>DEFAULT CONSTRUCTORS</b></p>
                <p>As stated, if you do not specify a constructor method a default constructor is used. For base classes the default constructor is:</p>
                <code>constructor() {}</code>
                <p>For derived classes, the default constructor is:</p>
                <code>constructor(...args) {
        super(...args);
}</code>
                </article>
        </section>
        <section class="main-section" id="If_..._Else_Statement">
                <header>If ... Else Statement</header>
                <article>
                        <p>Use the if statement to execute a statement if a logical condition is true. Use the optional else clause to execute a statement if the condition is false. An if statement looks as follows:</p>
                        <code>if (condition) {
        statement_1;
} else {
        statement_2;
}</code>
                        <p>Here the condition can be any expression that evaluates to true or false. See Boolean for an explanation of what evaluates to true and false. If condition evaluates to true, statement_1 is executed; otherwise, statement_2 is executed. statement_1 and statement_2 can be any statement, including further nested if statements.</p>
                        <p>You may also compound the statements using else if to have multiple conditions tested in sequence, as follows:</p>
                        <code>if (condition_1) {
        statement_1;
} else if (condition_2) {
        statement_2;
} else if (condition_n) {
        statement_n;
} else {
        statement_last;
} </code>
                <p>In the case of multiple conditions only the first logical condition which evaluates to true will be executed. To execute multiple statements, group them within a block statement ({ ... }) . In general, it's good practice to always use block statements, especially when nesting if statements:</p>
                <code>if (condition) {
        statement_1_runs_if_condition_is_true;
        statement_2_runs_if_condition_is_true;
} else {
        statement_3_runs_if_condition_is_false;
        statement_4_runs_if_condition_is_false;
}</code>
                <p>It is advisable to not use simple assignments in a conditional expression, because the assignment can be confused with equality when glancing over the code. For example, do not use the following code:</p>
                <code style="background-color: rgb(255, 204, 204); border-left-color: red">if (x = y) {
        /* statements here */
}</code>
                <p>If you need to use an assignment in a conditional expression, a common practice is to put additional parentheses around the assignment. For example:</p>
                <code>if ((x = y)) {
        /* statements here */
}</code>
                <p style="font-weight: 700; color: white; background-color: black; padding: 2px 0 2px 5px">Falsy values</p>
                <p>The following values evaluate to false (also known as Falsy values):</p>
                <li>false</li>
                <li>undefined</li>
                <li>null</li>
                <li>0</li>
                <li>NaN</li>
                <li>the empty string ("")</li>
                <p>All other values, including all objects, evaluate to true when passed to a conditional statement.</p>
                </article>
        </section>
        <section class="main-section" id="Switch_Statement">
                <header>Switch Statement</header>
                <article>
                        <p>A switch statement allows a program to evaluate an expression and attempt to match the expression's value to a case label. If a match is found, the program executes the associated statement. A switch statement looks as follows:</p>
                        <code>switch (expression) {
case label_1:
        statements_1
        [break;]
case label_2:
        statements_2
        [break;]
        ...
default:
        statements_def
        [break;]
}</code>
                        <p>The program first looks for a case clause with a label matching the value of expression and then transfers control to that clause, executing the associated statements. If no matching label is found, the program looks for the optional default clause, and if found, transfers control to that clause, executing the associated statements. If no default clause is found, the program continues execution at the statement following the end of switch. By convention, the default clause is the last clause, but it does not need to be so.</p>
                        <p>The optional break statement associated with each case clause ensures that the program breaks out of switch once the matched statement is executed and continues execution at the statement following switch. If break is omitted, the program continues execution at the next statement in the switch statement.</p>
                        <p><b>Example</b></p>
                        <P>In the following example, if fruittype evaluates to "Bananas", the program matches the value with case "Bananas" and executes the associated statement. When break is encountered, the program terminates switch and executes the statement following switch. If break were omitted, the statement for case "Cherries" would also be executed.</P>
                        <code>switch (fruittype) {
        case 'Oranges':
                console.log('Oranges are $0.59 a pound.');
                break;
        case 'Apples':
                console.log('Apples are $0.32 a pound.');
                break;
        case 'Bananas':
                console.log('Bananas are $0.48 a pound.');
                break;
        case 'Cherries':
                console.log('Cherries are $3.00 a pound.');
                break;
        case 'Mangoes':
                console.log('Mangoes are $0.56 a pound.');
                break;
        case 'Papayas':
                console.log('Mangoes and papayas are $2.79 a pound.');
                break;
        default:
                console.log('Sorry, we are out of ' + fruittype + '.');
}
console.log("Is there anything else you'd like?");</code>
                </article>
        </section>
        <section class="main-section" id="Declarations">
                <header>Declarations</header>
                <article>
                        <p>There are three kinds of declarations in JavaScript.</p>
                        <p style="color: rgb(77, 77, 255)">var</p>
                        <p style="padding-left: 10px">Declares a variable, optionally initializing it to a value.</p>
                        <p style="color: rgb(77, 77, 255)">let</p>
                        <p style="padding-left: 10px">Declares a block-scoped, local variable, optionally initializing it to a value.</p>
                        <p style="color: rgb(77, 77, 255)">const</p>
                        <p style="padding-left: 10px">Declares a block-scoped, read-only named constant.</p>
                        <p style="padding: 2px 0 2px 5px; background-color: black; color: white; width: 35%">Variables</p>
                        <p>You use variables as symbolic names for values in your application. The names of variables, called identifiers, conform to certain rules.</p>
                        <p>A JavaScript identifier must start with a letter, underscore (_), or dollar sign ($); subsequent characters can also be digits (0-9). Because JavaScript is case sensitive, letters include the characters "A" through "Z" (uppercase) and the characters "a" through "z" (lowercase).</p>
                        <p>You can use most of ISO 8859-1 or Unicode letters such as å and ü in identifiers (for more details see this blog post). You can also use the Unicode escape sequences as characters in identifiers.</p>
                        <p>Some examples of legal names are Number_hits, temp99, $credit, and _name.</p>
                        <p style="padding: 2px 0 2px 5px; background-color: black; color: white; width: 35%">Declaring variables</p>
                        <p>You can declare a variable in three ways:</p>
                        <li>With the keyword var. For example, var x = 42. This syntax can be used to declare both local and global variables.</li>
                        <li>By simply assigning it a value. For example, x = 42. If this form is used outside of a function, it declares a global variable. It generates a strict JavaScript warning. You shouldn't use this variant.</li>
                        <li>With the keyword let. For example, let y = 13. This syntax can be used to declare a block-scope local variable. See Variable scope below.</li>
                        <p style="padding: 2px 0 2px 5px; background-color: black; color: white; width: 35%">Evaluating variables</p>
                        <p>A variable declared using the var or let statement with no assigned value specified has the value of undefined.</p>
                        <p>An attempt to access an undeclared variable results in a ReferenceError exception being thrown:</p>
                        <code>var a;
console.log('The value of a is ' + a); // The value of a is undefined

console.log('The value of b is ' + b); // The value of b is undefined
var b;
// This one may puzzle you until you read 'Variable hoisting' below

console.log('The value of c is ' + c); // Uncaught ReferenceError: 
                                          c is not defined

let x;
console.log('The value of x is ' + x); // The value of x is undefined

console.log('The value of y is ' + y); // Uncaught ReferenceError: 
                                          y is not defined
let y;</code>
                        <p>You can use undefined to determine whether a variable has a value. In the following code, the variable input is not assigned a value, and the if statement evaluates to true.</p>
                        <code>var input;
if (input === undefined) {
        doThis();
} else {
        doThat();
}</code>
                        <p>The undefined value behaves as false when used in a boolean context. For example, the following code executes the function myFunction because the myArray element is undefined:</p>
                        <code>var myArray = [];
if (!myArray[0]) myFunction();</code>
                        <p>The undefined value converts to NaN when used in numeric context.</p>
                        <code>var a;
a + 2;  // Evaluates to NaN</code>
                        <p>When you evaluate a null variable, the null value behaves as 0 in numeric contexts and as false in boolean contexts. For example:</p>
                        <code>var n = null;
console.log(n * 32); // Will log 0 to the console</code>
                </article>
        </section>
        <section class="main-section" id="Comments">
                <header>Comments</header>
                <article>
                        <p>The syntax of comments is the same as in C++ and in many other languages:</p>
                        <code>// a one line comment

/* this is a longer, 
 * multi-line comment
 */

/* You can't, however, /* nest comments */ SyntaxError */</code>
                        <p>Comments behave like whitespace and are discarded during script execution.</p>
                </article>
        </section>
        <section class="main-section" id="Conditional_operator">
                <header>Conditional operator</header>
                <article>
                        <p>The conditional operator is the only JavaScript operator that takes three operands. The operator can have one of two values based on a condition. The syntax is:</p>
                        <code>condition ? val1 : val2</code>
                        <p>If condition is true, the operator has the value of val1. Otherwise it has the value of val2. You can use the conditional operator anywhere you would use a standard operator.</p>
                        <p>For example,</p>
                        <code>var status = (age >= 18) ? 'adult' : 'minor';</code>
                        <p>This statement assigns the value "adult" to the variable status if age is eighteen or more. Otherwise, it assigns the value "minor" to status.</p>
                </article>
        </section>
        <section class="main-section" id="String_objects">
                <header>String objects</header>
                <article>
                        <p>The String object is a wrapper around the string primitive data type.</p>
                        <code>var s = new String('foo'); // Creates a String object
console.log(s); // Displays: {'0': 'f', '1': 'o', '2': 'o'}
typeof s; // Returns 'object'</code>
                        <p>You can call any of the methods of the String object on a string literal value—JavaScript automatically converts the string literal to a temporary String object, calls the method, then discards the temporary String object. You can also use the String.length property with a string literal.</p>
                        <p>You should use string literals unless you specifically need to use a String object, because String objects can have counterintuitive behavior. For example:</p>
                        <code>var s1 = '2 + 2'; // Creates a string literal value
var s2 = new String('2 + 2'); // Creates a String object
eval(s1); // Returns the number 4
eval(s2); // Returns the string "2 + 2"</code>
                        <p>A String object has one property, length, that indicates the number of UTF-16 code units in the string. For example, the following code assigns x the value 13, because "Hello, World!" has 13 characters, each represented by one UTF-16 code unit. You can access each code unit using an array bracket style. You can't change individual characters because strings are immutable array-like objects:</p>
                        <code>var mystring = 'Hello, World!';
var x = mystring.length;
mystring[0] = 'L'; // This has no effect, because strings are immutable
mystring[0]; // This returns "H"</code>
                        <p>Characters whose Unicode scalar values are greater than U+FFFF (such as some rare Chinese/Japanese/Korean/Vietnamese characters and some emoji) are stored in UTF-16 with two surrogate code units each. For example, a string containing the single character U+1F600 "Emoji grinning face" will have length 2. Accessing the individual code units in such a string using brackets may have undesirable consequences such as the formation of strings with unmatched surrogate code units, in violation of the Unicode standard. (Examples should be added to this page after MDN bug 857438 is fixed.) See also String.fromCodePoint() or String.prototype.codePointAt().</p>
                        <p>A String object has a variety of methods: for example those that return a variation on the string itself, such as substring and toUpperCase.</p>
                </article>
        </section>
        <section class="main-section" id="Arrow_functions">
                <header>Arrow functions</header>
                <article>
                        <p>An arrow function expression (previously, and now incorrectly known as fat arrow function) has a shorter syntax compared to function expressions and does not have its own this, arguments, super, or new.target. Arrow functions are always anonymous. See also this hacks.mozilla.org blog post: "ES6 In Depth: Arrow functions".</p>
                        <p>Two factors influenced the introduction of arrow functions: shorter functions and non-binding of this.</p>
                        <p style="padding: 2px 0 2px 5px; background-color: black; color: white; width: 35%">Shorter functions</p>
                        <p>In some functional patterns, shorter functions are welcome. Compare:</p>
                        <code>var a = [
        'Hydrogen',
        'Helium',
        'Lithium',
        'Beryllium'
];

var a2 = a.map(function(s) { return s.length; });

console.log(a2); // logs [8, 6, 7, 9]

var a3 = a.map(s => s.length);

console.log(a3); // logs [8, 6, 7, 9]</code>
                        <p style="padding: 2px 0 2px 5px; background-color: black; color: white; width: 35%">No separate this</p>
                        <p>Until arrow functions, every new function defined its own this value (a new object in the case of a constructor, undefined in strict mode function calls, the base object if the function is called as an "object method", etc.). This proved to be less than ideal with an object-oriented style of programming.</p>
                        <code>function Person() {
        // The Person() constructor defines `this` as itself.
        this.age = 0;

        setInterval(function growUp() {
                // In nonstrict mode, the growUp() function defines `this` 
                // as the global object, which is different from the `this`
                // defined by the Person() constructor.
                this.age++;
        }, 1000);
}

var p = new Person();</code>
                        <p>In ECMAScript 3/5, this issue was fixed by assigning the value in this to a variable that could be closed over.</p>
                        <code>function Person() {
        var self = this; // Some choose `that` instead of `self`. 
                                // Choose one and be consistent.
        self.age = 0;

        setInterval(function growUp() {
                // The callback refers to the `self` variable of which
                // the value is the expected object.
                self.age++;
        }, 1000);
}</code>
                        <p>Alternatively, a bound function could be created so that the proper this value would be passed to the growUp() function.</p>
                        <p>An arrow function does not have its own this; the this value of the enclosing execution context is used. Thus, in the following code, the this within the function that is passed to setInterval has the same value as this in the enclosing function:</p>
                        <code>function Person() {
        this.age = 0;

        setInterval(() => {
                this.age++; // |this| properly refers to the person object
        }, 1000);
}

var p = new Person();</code>
                </article>
        </section>
        <section class="main-section" id="Defining_getters_and_setters">
                <header>Defining getters and setters</header>
                <article>
                        <p>A getter is a method that gets the value of a specific property. A setter is a method that sets the value of a specific property. You can define getters and setters on any predefined core object or user-defined object that supports the addition of new properties. The syntax for defining getters and setters uses the object literal syntax.</p>
                        <p>The following illustrates how getters and setters could work for a user-defined object o.</p>
                        <code>var o = {
        a: 7,
        get b() { 
                return this.a + 1;
        },
        set c(x) {
                this.a = x / 2;
        }
};

console.log(o.a); // 7
console.log(o.b); // 8
o.c = 50;
console.log(o.a); // 25</code>
                        <p>The o object's properties are:</p>
                        <li>o.a — a number</li>
                        <li>o.b — a getter that returns o.a plus 1</li>
                        <li>o.c — a setter that sets the value of o.a to half of the value o.c is being set to</li>
                        <p>Please note that function names of getters and setters defined in an object literal using "[gs]et property()" (as opposed to __define[GS]etter__ ) are not the names of the getters themselves, even though the [gs]et propertyName(){ } syntax may mislead you to think otherwise. To name a function in a getter or setter using the "[gs]et property()" syntax, define an explicitly named function programmatically using Object.defineProperty (or the Object.prototype.__defineGetter__ legacy fallback).</p>
                        <p>The following code illustrates how getters and setters can extend the Date prototype to add a year property to all instances of the predefined Date class. It uses the Date class's existing getFullYear and setFullYear methods to support the year property's getter and setter.</p>
                        <p>These statements define a getter and setter for the year property:</p>
                        <code>var d = Date.prototype;
Object.defineProperty(d, 'year', {
        get: function() { return this.getFullYear(); },
        set: function(y) { this.setFullYear(y); }
});</code>
                        <p>These statements use the getter and setter in a Date object:</p>
                        <code>var now = new Date();
console.log(now.year); // 2000
now.year = 2001; // 987617605170
console.log(now);
// Wed Apr 18 11:13:25 GMT-0700 (Pacific Daylight Time) 2001</code>
                        <p>In principle, getters and setters can be either</p>
                        <li>defined using object initializers, or</li>
                        <li>added later to any object at any time using a getter or setter adding method.</li>
                        <p>When defining getters and setters using object initializers all you need to do is to prefix a getter method with get and a setter method with set. Of course, the getter method must not expect a parameter, while the setter method expects exactly one parameter (the new value to set). For instance:</p>
                        <code>var o = {
        a: 7,
        get b() { return this.a + 1; },
        set c(x) { this.a = x / 2; }
};</code>
                        <p>Getters and setters can also be added to an object at any time after creation using the Object.defineProperties method. This method's first parameter is the object on which you want to define the getter or setter. The second parameter is an object whose property names are the getter or setter names, and whose property values are objects for defining the getter or setter functions. Here's an example that defines the same getter and setter used in the previous example:</p>
                        <code>var o = { a: 0 };

Object.defineProperties(o, {
        'b': { get: function() { return this.a + 1; } },
        'c': { set: function(x) { this.a = x / 2; } }
});

o.c = 10; // Runs the setter, which assigns 10 / 2 (5) to the 'a' property
console.log(o.b); // Runs the getter, which yields a + 1 or 6</code>
                        <p>Which of the two forms to choose depends on your programming style and task at hand. If you already go for the object initializer when defining a prototype you will probably most of the time choose the first form. This form is more compact and natural. However, if you need to add getters and setters later — because you did not write the prototype or particular object — then the second form is the only possible form. The second form probably best represents the dynamic nature of JavaScript — but it can make the code hard to read and understand.</p>
                </article>
        </section>
        <section class="main-section" id="Reference">
                <header>Reference</header>
                <article>
                        <li>
                                All the documentation in this page is taken from 
                                <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide" target="_blank">MDN</a>
                        </li>
                </article>
        </section>

    </main>

</body>
</html>